/*********************************************************************
*            (c) 1995 - 2018 SEGGER Microcontroller GmbH             *
*                        The Embedded Experts                        *
*                           www.segger.com                           *
**********************************************************************

-------------------------- END-OF-HEADER -----------------------------

File    : ST_STM32H750_400Mhz_Traceconfig.JLinkScript
Purpose : Examplescript to modify TracePortWidth and Pin init
Literature:
  [1]  J-Link User Guide

Additional information:
  For more information about public functions that can be implemented in order to customize J-Link actions, please refer to [1]
*/

/*********************************************************************
*                                                                     
*       ConfigTargetSettings   
*
*  Function description
*    Called before InitTarget(). Mainly used to set some global DLL variables to customize the
*    normal  connect  procedure.  For  ARM  CoreSight  devices  this  may  be  specifying  the  base
*    address of some CoreSight components (ETM, â€¦) that cannot be auto-detected by J-Link
*    due to erroneous ROM tables etc. May also be used to specify the device name in case
*    debugger does not pass it to the DLL.                    
*
*  Notes
*    (1) May not, under absolutely NO circumstances, call any API functions that perform target communication.
*    (2) Should only set some global DLL variables
*
*  Return value
*    >= 0  O.K.
*     < 0  Error
*      -1  Unspecified error
*/
int ConfigTargetSettings(void) {
  //
  // Enable erase for all flash banks (e.g. QSPI)
  //
  JLINK_SYS_Report("-ConfigSettings.-");
  JLINK_ExecCommand("CORESIGHT_SetCSTFBaseAddr = 0xE00F3000 ForceUnlock = 1 APIndex = 2");
  JLINK_ExecCommand("CORESIGHT_SetTPIUBaseAddr = 0xE00F5000 ForceUnlock = 1 APIndex = 2");
  JLINK_ExecCommand("CORESIGHT_SetTMCBaseAddr = 0xE00F4000 ForceUnlock = 1 APIndex = 2");
  return 0;
}

/*********************************************************************
*
*       OnTraceStart()
*
*  Function description
*    If present, called right before trace is started.
*    Used to initialize MCU specific trace related things like configuring the trace pins for alternate function.
*
*  Return value
*    >= 0:  O.K.
*     < 0:  Error
*
*  Notes
*    (1) May use high-level API functions like JLINK_MEM_ etc.
*    (2) Should not call JLINK_TARGET_Halt(). Can rely on target being halted when entering this function
*/
int OnTraceStart(void) {
  U32 RCC_AHB4ENR_Addr;
  U32 GPIOE_MODER_Addr;
  U32 GPIOE_PUPDR_Addr;
  U32 GPIOE_OSPEEDR_Addr;
  U32 GPIOE_AFRL_Addr;
  
  U32 GPIOG_MODER_Addr;
  U32 GPIOG_PUPDR_Addr;
  U32 GPIOG_OSPEEDR_Addr;
  U32 GPIOG_AFRH_Addr;

  U32 DBGMCU_CR_Addr;
  U32 iTCLK;
  U32 iTD0;
  U32 iTD1;
  U32 iTD2;
  U32 iTD3;
  U32 EdgeTCLK;
  U32 EdgeTD;
  U32 v;
  U32 PortWidth;
  //
  // Adjust sampling point of trace pin (Optional: not needed for this cpu)
  //
  //JLINK_ExecCommand("TraceSampleAdjust TD=2000"); 
  //
  // Set Trace Portwidth(Optional): Default 4 Pin Trace, other possibilities: 1, 2, 4
  //
  //JLINK_TRACE_PortWidth = 4;
  //
  // RCC_AHB4ENR_Addr   0x580244E0          Periphal clock register
  // GPIOE_MODER:       0x58021000          GPIO Port mode register
  // GPIOE_PUPDR:       0x5802100C          GPIO Pullup/Puldown register
  // GPIOE_OSPEEDR:     0x58021008          GPIO output speed register
  // GPIOE_AFRL:        0x58021020          GPIO Alternate function low register
  // DBGMCU_CR:         0x5C001004          Debug MCU register
  //
  //   PE2 => TCLK
  //   PG13 => TD0
  //   PG14 => TD1
  //   PE5 => TD2
  //   PE6 => TD3
  //
  //
  // Init register addresses
  //
  JLINK_SYS_Report("Start: Initializing trace pins.");

  RCC_AHB4ENR_Addr   = 0x580244E0;

  GPIOE_MODER_Addr   = 0x58021000;
  GPIOE_PUPDR_Addr   = 0x5802100C;
  GPIOE_OSPEEDR_Addr = 0x58021008;
  GPIOE_AFRL_Addr    = 0x58021020;
  
  GPIOG_MODER_Addr   = 0x58021800;
  GPIOG_PUPDR_Addr   = 0x5802180C;
  GPIOG_OSPEEDR_Addr = 0x58021808;
  GPIOG_AFRH_Addr    = 0x58021824;

  DBGMCU_CR_Addr     = 0x5C001004;

  iTCLK = 2;
  iTD0  = 13;
  iTD1  = 14;
  iTD2  = 5;
  iTD3  = 6;

  PortWidth = JLINK_TRACE_PortWidth;
  //
  // Set drivestrength 
  // 0: Low speed
  // 1: Medium speed
  // 2: High speed
  // 3: Very high speed
  //
  EdgeTCLK = 3;
  EdgeTD   = 3;
  //
  // Init pins
  //
  v  = JLINK_MEM_ReadU32(RCC_AHB4ENR_Addr);
  JLINK_MEM_WriteU32(RCC_AHB4ENR_Addr, v | 1 << 6); // Enable clock for GPIOG

  v  = JLINK_MEM_ReadU32(RCC_AHB4ENR_Addr);
  JLINK_MEM_WriteU32(RCC_AHB4ENR_Addr, v | 1 << 4); // Enable clock for GPIOE
  //
  // TCLK init
  //
  v  =  JLINK_MEM_ReadU32(GPIOE_MODER_Addr);
  v  &= ~(3 << (2 * iTCLK));               // Mask Mode register
  v  |= (2 << (2 * iTCLK));                // Set alt function mode
  JLINK_MEM_WriteU32(GPIOE_MODER_Addr, v);
  v  =  JLINK_MEM_ReadU32(GPIOE_PUPDR_Addr);
  v  &= ~(3 << (2 * iTCLK));               // Mask PUP register
  v  |= (1 << (2 * iTCLK));                // Set PUP register (Pullup)
  JLINK_MEM_WriteU32(GPIOE_PUPDR_Addr, v);
  v  =  JLINK_MEM_ReadU32(GPIOE_OSPEEDR_Addr);
  v  &= ~(3 << (2 * iTCLK));               // Mask OSPEED register
  v  |= (EdgeTCLK << (2 * iTCLK));                // Set OSPEED register (very high speed)
  JLINK_MEM_WriteU32(GPIOE_OSPEEDR_Addr, v);
  v  =  JLINK_MEM_ReadU32(GPIOE_AFRL_Addr);
  v  &= ~(15 << (4 * iTCLK));              // Select alt func 0
  JLINK_MEM_WriteU32(GPIOE_AFRL_Addr, v);
  //
  // TD0 init
  //
  v  =  JLINK_MEM_ReadU32(GPIOG_MODER_Addr);
  v  &= ~(3 << (2 * iTD0));               // Mask Mode register
  v  |= (2 << (2 * iTD0));                // Set alt function mode
  JLINK_MEM_WriteU32(GPIOG_MODER_Addr, v);
  v  =  JLINK_MEM_ReadU32(GPIOG_PUPDR_Addr);
  v  &= ~(3 << (2 * iTD0));               // Mask PUP register
  v  |= (1 << (2 * iTD0));                // Set PUP register (Pullup)
  JLINK_MEM_WriteU32(GPIOG_PUPDR_Addr, v);
  v  =  JLINK_MEM_ReadU32(GPIOG_OSPEEDR_Addr);
  v  &= ~(3 << (2 * iTD0));               // Mask OSPEED register
  v  |= (EdgeTD << (2 * iTD0));                // Set OSPEED register (very high speed)
  JLINK_MEM_WriteU32(GPIOG_OSPEEDR_Addr, v);
  v  =  JLINK_MEM_ReadU32(GPIOG_AFRH_Addr);
  v  &= ~(15 << (4 * (iTD0 - 8)));              // Select alt func 0
  JLINK_MEM_WriteU32(GPIOG_AFRH_Addr, v);
  //
  // TD1 init
  //
  if (PortWidth > 1) {
      v  =  JLINK_MEM_ReadU32(GPIOG_MODER_Addr);
      v  &= ~(3 << (2 * iTD1));               // Mask Mode register
      v  |= (2 << (2 * iTD1));                // Set alt function mode
      JLINK_MEM_WriteU32(GPIOG_MODER_Addr, v);
      v  =  JLINK_MEM_ReadU32(GPIOG_PUPDR_Addr);
      v  &= ~(3 << (2 * iTD1));               // Mask PUP register
      v  |= (1 << (2 * iTD1));                // Set PUP register (Pullup)
      JLINK_MEM_WriteU32(GPIOG_PUPDR_Addr, v);
      v  =  JLINK_MEM_ReadU32(GPIOG_OSPEEDR_Addr);
      v  &= ~(3 << (2 * iTD1));               // Mask OSPEED register
      v  |= (EdgeTD << (2 * iTD1));                // Set OSPEED register (very high speed)
      JLINK_MEM_WriteU32(GPIOG_OSPEEDR_Addr, v);
      v  =  JLINK_MEM_ReadU32(GPIOG_AFRH_Addr);
      v  &= ~(15 << (4 * (iTD1 - 8)));              // Select alt func 0
      JLINK_MEM_WriteU32(GPIOG_AFRH_Addr, v);
  }
  //
  // TD2 & TD3 init
  //
  if (PortWidth > 2) {
      //
      // TD2 init
      //
      v  =  JLINK_MEM_ReadU32(GPIOE_MODER_Addr);
      v  &= ~(3 << (2 * iTD2));               // Mask Mode register
      v  |= (2 << (2 * iTD2));                // Set alt function mode
      JLINK_MEM_WriteU32(GPIOE_MODER_Addr, v);
      v  =  JLINK_MEM_ReadU32(GPIOE_PUPDR_Addr);
      v  &= ~(3 << (2 * iTD2));               // Mask PUP register
      v  |= (1 << (2 * iTD2));                // Set PUP register (Pullup)
      JLINK_MEM_WriteU32(GPIOE_PUPDR_Addr, v);
      v  =  JLINK_MEM_ReadU32(GPIOE_OSPEEDR_Addr);
      v  &= ~(3 << (2 * iTD2));               // Mask OSPEED register
      v  |= (EdgeTD << (2 * iTD2));                // Set OSPEED register (very high speed)
      JLINK_MEM_WriteU32(GPIOE_OSPEEDR_Addr, v);
      v  =  JLINK_MEM_ReadU32(GPIOE_AFRL_Addr);
      v  &= ~(15 << (4 * iTD2));              // Select alt func 0
      JLINK_MEM_WriteU32(GPIOE_AFRL_Addr, v);
      //
      // TD3 init
      //
      v  =  JLINK_MEM_ReadU32(GPIOE_MODER_Addr);
      v  &= ~(3 << (2 * iTD3));               // Mask Mode register
      v  |= (2 << (2 * iTD3));                // Set alt function mode
      JLINK_MEM_WriteU32(GPIOE_MODER_Addr, v);
      v  =  JLINK_MEM_ReadU32(GPIOE_PUPDR_Addr);
      v  &= ~(3 << (2 * iTD3));               // Mask PUP register
      v  |= (1 << (2 * iTD3));                // Set PUP register (Pullup)
      JLINK_MEM_WriteU32(GPIOE_PUPDR_Addr, v);
      v  =  JLINK_MEM_ReadU32(GPIOE_OSPEEDR_Addr);
      v  &= ~(3 << (2 * iTD3));               // Mask OSPEED register
      v  |= (EdgeTD << (2 * iTD3));                // Set OSPEED register (very high speed)
      JLINK_MEM_WriteU32(GPIOE_OSPEEDR_Addr, v);
      v  =  JLINK_MEM_ReadU32(GPIOE_AFRL_Addr);
      v  &= ~(15 << (4 * iTD3));              // Select alt func 0
      JLINK_MEM_WriteU32(GPIOE_AFRL_Addr, v);

  }
  //
  //  Config DBUGMCU
  //
  v  =  JLINK_MEM_ReadU32(DBGMCU_CR_Addr);               // Debug MCU enables traceclk (STM32H7 specific)
  v  &= ~(1 << 20);               // Mask Traceclk Register
  v  |= (1 << 20);                // Enable Traceclk
  v  |= (1 << 21);                // D1DBGCKEN
  v  |= (1 << 22);                // D3DBGCKEN
  JLINK_MEM_WriteU32(DBGMCU_CR_Addr, v);

  JLINK_SYS_Report("End: Initializing trace pins.");
  return 0;
}
