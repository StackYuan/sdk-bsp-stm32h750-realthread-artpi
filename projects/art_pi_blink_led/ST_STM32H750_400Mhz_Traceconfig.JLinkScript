/*********************************************************************
*            (c) 1995 - 2018 SEGGER Microcontroller GmbH             *
*                        The Embedded Experts                        *
*                           www.segger.com                           *
**********************************************************************

-------------------------- END-OF-HEADER -----------------------------

File    : ST_STM32H750_Modified_Traceconfig.JLinkScript
Purpose : Examplescript to modify TracePortWidth and Pin init
Literature:
  [1]  J-Link User Guide

Additional information:
  For more information about public functions that can be implemented in order to customize J-Link actions, please refer to [1]
*/

/*********************************************************************
*
*       OnTraceStart()
*
*  Function description
*    If present, called right before trace is started.
*    Used to initialize MCU specific trace related things like configuring the trace pins for alternate function.
*
*  Return value
*    >= 0:  O.K.
*     < 0:  Error
*
*  Notes
*    (1) May use high-level API functions like JLINK_MEM_ etc.
*    (2) Should not call JLINK_TARGET_Halt(). Can rely on target being halted when entering this function
*/
int OnTraceStart(void) {
  U32 RCC_AHB4ENR_Addr;
  U32 GPIOE_MODER_Addr;
  U32 GPIOE_PUPDR_Addr;
  U32 GPIOE_OSPEEDR_Addr;
  U32 GPIOE_AFRL_Addr;
  
  U32 GPIOG_MODER_Addr;
  U32 GPIOG_PUPDR_Addr;
  U32 GPIOG_OSPEEDR_Addr;
  U32 GPIOG_AFRH_Addr;

  U32 DBGMCU_CR_Addr;
  U32 iTCLK;
  U32 iTD0;
  U32 iTD1;
  U32 iTD2;
  U32 iTD3;
  U32 EdgeTCLK;
  U32 EdgeTD;
  U32 v;
  U32 PortWidth;
  //
  // Adjust sampling point of trace pin (Optional: not needed for this cpu)
  //
  //JLINK_ExecCommand("TraceSampleAdjust TD=2000"); 
  //
  // Set Trace Portwidth(Optional): Default 4 Pin Trace, other possibilities: 1, 2, 4
  //
  //JLINK_TRACE_PortWidth = 4;
  //
  // RCC_AHB1ENR:    0x40023830          Periphal clock register
  // GPIOE_MODER:    0x40021000          GPIO Port mode register
  // GPIOE_PUPDR:    0x4002100C          GPIO Pullup/Puldown register
  // GPIOE_OSPEEDR:  0x40021008          GPIO output speed register
  // GPIOE_AFRL:     0x40021020          GPIO Alternate function low register
  // DBGMCU_CR:      0xE0042004          Debug MCU register
  //
  //   PE2 => TCLK
  //   PG13 => TD0
  //   PG14 => TD1
  //   PE5 => TD2
  //   PE6 => TD3
  //
  //
  // Init register addresses
  //
  JLINK_SYS_Report("Start: Initializing trace pins");
  RCC_AHB4ENR_Addr   = 0x580244E0;

  GPIOE_MODER_Addr   = 0x58021000;
  GPIOE_PUPDR_Addr   = 0x5802100C;
  GPIOE_OSPEEDR_Addr = 0x58021008;
  GPIOE_AFRL_Addr    = 0x58021020;
  
  GPIOG_MODER_Addr   = 0x58021800;
  GPIOG_PUPDR_Addr   = 0x5802180C;
  GPIOG_OSPEEDR_Addr = 0x58021808;
  GPIOG_AFRH_Addr    = 0x58021824;

  DBGMCU_CR_Addr     = 0x5C001004;

  iTCLK = 2;
  iTD0  = 13;
  iTD1  = 14;
  iTD2  = 5;
  iTD3  = 6;

  PortWidth = JLINK_TRACE_PortWidth;
  //
  // Set drivestrength 
  // 0: Low speed
  // 1: Medium speed
  // 2: High speed
  // 3: Very high speed
  //
  EdgeTCLK = 3;
  EdgeTD   = 3;
  //
  // Init pins
  //
  v  = JLINK_MEM_ReadU32(RCC_AHB4ENR_Addr);
  JLINK_MEM_WriteU32(RCC_AHB4ENR_Addr, v | 1 << 6); // Enable clock for GPIOG

  v  = JLINK_MEM_ReadU32(RCC_AHB4ENR_Addr);
  JLINK_MEM_WriteU32(RCC_AHB4ENR_Addr, v | 1 << 4); // Enable clock for GPIOE
  //
  // TCLK init
  //
  v  =  JLINK_MEM_ReadU32(GPIOE_MODER_Addr);
  v  &= ~(3 << (2 * iTCLK));               // Mask Mode register
  v  |= (2 << (2 * iTCLK));                // Set alt function mode
  JLINK_MEM_WriteU32(GPIOE_MODER_Addr, v);
  v  =  JLINK_MEM_ReadU32(GPIOE_PUPDR_Addr);
  v  &= ~(3 << (2 * iTCLK));               // Mask PUP register
  v  |= (1 << (2 * iTCLK));                // Set PUP register (Pullup)
  JLINK_MEM_WriteU32(GPIOE_PUPDR_Addr, v);
  v  =  JLINK_MEM_ReadU32(GPIOE_OSPEEDR_Addr);
  v  &= ~(3 << (2 * iTCLK));               // Mask OSPEED register
  v  |= (EdgeTCLK << (2 * iTCLK));                // Set OSPEED register (very high speed)
  JLINK_MEM_WriteU32(GPIOE_OSPEEDR_Addr, v);
  v  =  JLINK_MEM_ReadU32(GPIOE_AFRL_Addr);
  v  &= ~(15 << (4 * iTCLK));              // Select alt func 0
  JLINK_MEM_WriteU32(GPIOE_AFRL_Addr, v);
  //
  // TD0 init
  //
  v  =  JLINK_MEM_ReadU32(GPIOG_MODER_Addr);
  v  &= ~(3 << (2 * iTD0));               // Mask Mode register
  v  |= (2 << (2 * iTD0));                // Set alt function mode
  JLINK_MEM_WriteU32(GPIOG_MODER_Addr, v);
  v  =  JLINK_MEM_ReadU32(GPIOG_PUPDR_Addr);
  v  &= ~(3 << (2 * iTD0));               // Mask PUP register
  v  |= (1 << (2 * iTD0));                // Set PUP register (Pullup)
  JLINK_MEM_WriteU32(GPIOG_PUPDR_Addr, v);
  v  =  JLINK_MEM_ReadU32(GPIOG_OSPEEDR_Addr);
  v  &= ~(3 << (2 * iTD0));               // Mask OSPEED register
  v  |= (EdgeTD << (2 * iTD0));                // Set OSPEED register (very high speed)
  JLINK_MEM_WriteU32(GPIOG_OSPEEDR_Addr, v);
  v  =  JLINK_MEM_ReadU32(GPIOG_AFRH_Addr);
  v  &= ~(15 << (4 * (iTD0 - 8)));              // Select alt func 0
  JLINK_MEM_WriteU32(GPIOG_AFRH_Addr, v);
  //
  // TD1 init
  //
  if (PortWidth > 1) {
      v  =  JLINK_MEM_ReadU32(GPIOG_MODER_Addr);
      v  &= ~(3 << (2 * iTD1));               // Mask Mode register
      v  |= (2 << (2 * iTD1));                // Set alt function mode
      JLINK_MEM_WriteU32(GPIOG_MODER_Addr, v);
      v  =  JLINK_MEM_ReadU32(GPIOG_PUPDR_Addr);
      v  &= ~(3 << (2 * iTD1));               // Mask PUP register
      v  |= (1 << (2 * iTD1));                // Set PUP register (Pullup)
      JLINK_MEM_WriteU32(GPIOG_PUPDR_Addr, v);
      v  =  JLINK_MEM_ReadU32(GPIOG_OSPEEDR_Addr);
      v  &= ~(3 << (2 * iTD1));               // Mask OSPEED register
      v  |= (EdgeTD << (2 * iTD1));                // Set OSPEED register (very high speed)
      JLINK_MEM_WriteU32(GPIOG_OSPEEDR_Addr, v);
      v  =  JLINK_MEM_ReadU32(GPIOG_AFRH_Addr);
      v  &= ~(15 << (4 * (iTD1 - 8)));              // Select alt func 0
      JLINK_MEM_WriteU32(GPIOG_AFRH_Addr, v);
  }
  //
  // TD2 & TD3 init
  //
  if (PortWidth > 2) {
      //
      // TD2 init
      //
      v  =  JLINK_MEM_ReadU32(GPIOE_MODER_Addr);
      v  &= ~(3 << (2 * iTD2));               // Mask Mode register
      v  |= (2 << (2 * iTD2));                // Set alt function mode
      JLINK_MEM_WriteU32(GPIOE_MODER_Addr, v);
      v  =  JLINK_MEM_ReadU32(GPIOE_PUPDR_Addr);
      v  &= ~(3 << (2 * iTD2));               // Mask PUP register
      v  |= (1 << (2 * iTD2));                // Set PUP register (Pullup)
      JLINK_MEM_WriteU32(GPIOE_PUPDR_Addr, v);
      v  =  JLINK_MEM_ReadU32(GPIOE_OSPEEDR_Addr);
      v  &= ~(3 << (2 * iTD2));               // Mask OSPEED register
      v  |= (EdgeTD << (2 * iTD2));                // Set OSPEED register (very high speed)
      JLINK_MEM_WriteU32(GPIOE_OSPEEDR_Addr, v);
      v  =  JLINK_MEM_ReadU32(GPIOE_AFRL_Addr);
      v  &= ~(15 << (4 * iTD2));              // Select alt func 0
      JLINK_MEM_WriteU32(GPIOE_AFRL_Addr, v);
      //
      // TD3 init
      //
      v  =  JLINK_MEM_ReadU32(GPIOE_MODER_Addr);
      v  &= ~(3 << (2 * iTD3));               // Mask Mode register
      v  |= (2 << (2 * iTD3));                // Set alt function mode
      JLINK_MEM_WriteU32(GPIOE_MODER_Addr, v);
      v  =  JLINK_MEM_ReadU32(GPIOE_PUPDR_Addr);
      v  &= ~(3 << (2 * iTD3));               // Mask PUP register
      v  |= (1 << (2 * iTD3));                // Set PUP register (Pullup)
      JLINK_MEM_WriteU32(GPIOE_PUPDR_Addr, v);
      v  =  JLINK_MEM_ReadU32(GPIOE_OSPEEDR_Addr);
      v  &= ~(3 << (2 * iTD3));               // Mask OSPEED register
      v  |= (EdgeTD << (2 * iTD3));                // Set OSPEED register (very high speed)
      JLINK_MEM_WriteU32(GPIOE_OSPEEDR_Addr, v);
      v  =  JLINK_MEM_ReadU32(GPIOE_AFRL_Addr);
      v  &= ~(15 << (4 * iTD3));              // Select alt func 0
      JLINK_MEM_WriteU32(GPIOE_AFRL_Addr, v);
      //
      // Enable trace and set portwidth
      //
      v  =  JLINK_MEM_ReadU32(DBGMCU_CR_Addr);               // Debug MCU sets how many Pins to use for trace (STM32 specific)
      v  &= ~(7 << 5);               // Mask Register
      v  |= (7 << 5);                // Enable Trace and Select configured Tracepins for Trace
      JLINK_MEM_WriteU32(DBGMCU_CR_Addr, v);
  }
  if (PortWidth < 3){
    JLINK_SYS_Report("DBGMCU Init");
    v  =  JLINK_MEM_ReadU32(DBGMCU_CR_Addr);               // Debug MCU sets how many Pins to use for trace (STM32 specific)
    v  &= ~(7 << 5);               // Mask Register
    v  |= (1 << 5);                // Enable Trace
    v  |= ((PortWidth) << 6);                // Enable Trace and Select configured Tracepins for Trace
    JLINK_MEM_WriteU32(DBGMCU_CR_Addr, v);
  }
  JLINK_SYS_Report("End: Initializing trace pins");
  return 0;
}
